# -*- coding: utf-8 -*-
"""Graph Class Copy of BA_Shapes.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-G-54HRD0US3vXbV0qgutiucTH170R32
"""

import os
from matplotlib import pyplot as plt
from matplotlib.backends.backend_agg import FigureCanvasAgg as FigureCanvas
from matplotlib.figure import Figure
import matplotlib.colors as colors
import networkx as nx
import numpy as np
from torch.utils.tensorboard import SummaryWriter
import math
import abc
import itertools

def get_color_concept(color_str):
    if color_str == 'green':
        return 5
    elif color_str == 'red':
        return 6
    elif color_str == 'blue':
        return 7

class FeatureGen(metaclass=abc.ABCMeta):
    """Feature Generator base class."""
    @abc.abstractmethod
    def gen_node_features(self, G):
        pass

class ConstFeatureGen(FeatureGen):
    """Constant Feature class."""
    def __init__(self, val):
        self.val = val

    def gen_node_features(self, G):
        feat_dict = {i:{'feat': np.array(self.val, dtype=np.float32)} for i in G.nodes()}
        nx.set_node_attributes(G, feat_dict)

class ColorFeatureGen(FeatureGen):
    """Color feature gen class"""
    def __init__(self, val):
        self.val = val

    def gen_node_features(self, G):
        bin_encoding = np.array(list('{0:0b}'.format(self.val)), dtype=np.float32)
        print('binary encoding ', bin_encoding)
        feat_dict = {i: {'feat': bin_encoding} for i in G.nodes()}
        nx.set_node_attributes(G, feat_dict)

# BA Shapes Code is from GNNExplainer repo: https://github.com/RexYing/gnn-model-explainer/tree/bc984829f4f4829e93c760e9bbdc8e73f96e2cc1
def house(start, color, role_start=0):
    graph = nx.Graph()
    graph.add_nodes_from(range(start, start + 5))
    graph.add_edges_from(
        [
            (start, start + 1),
            (start + 1, start + 2),
            (start + 2, start + 3),
            (start + 3, start),
        ]
    )
    # graph.add_edges_from([(start, start + 2), (start + 1, start + 3)])
    graph.add_edges_from([(start + 4, start), (start + 4, start + 1)])
    roles = [role_start, role_start, role_start + 1, role_start + 1, role_start + 2]
    print(color)
    concepts = np.ones(len(roles)) * color

    print("This charlotte ", concepts)

    feature_generator = ColorFeatureGen(color)
    feature_generator.gen_node_features(graph)

    return graph, roles, concepts

def circle(start, color, role_start=0):
    len_cycle = 6
    graph = nx.Graph()
    graph.add_nodes_from(range(start, start + len_cycle))
    for i in range(6):
        graph.add_edges_from([(start + i, start + i + 1)])
    graph.add_edges_from([(start + len_cycle - 1, start)])
    roles = [role_start] * len_cycle
    concepts = np.ones(len(roles)) * color

    feature_generator = ColorFeatureGen(color)
    feature_generator.gen_node_features(graph)

    return graph, roles, concepts

def ba(start, width, role_start=0, m=5):
    graph = nx.barabasi_albert_graph(width, m)
    graph.add_nodes_from(range(start, start + width))
    nids = sorted(graph)
    mapping = {nid: start + i for i, nid in enumerate(nids)}
    graph = nx.relabel_nodes(graph, mapping)

    roles = [role_start for i in range(width)]

    color_str = 'green'
    concepts = np.ones(len(roles)) * get_color_concept(color_str)

    feature_generator = ColorFeatureGen(get_color_concept(color_str))
    feature_generator.gen_node_features(graph)

    return graph, roles, concepts


def build_graph(width_basis, basis_type, list_shapes, colour, start=0, rdm_basis_plugins=False, add_random_edges=0, m=5):
    if basis_type == "ba":
        basis, role_id, concepts = eval(basis_type)(start, width_basis, m=m)

    n_basis, n_shapes = nx.number_of_nodes(basis), len(list_shapes)
    start += n_basis  # indicator of the id of the next node

    # Sample (with replacement) where to attach the new motifs
    if rdm_basis_plugins is True:
        plugins = np.random.choice(n_basis, n_shapes, replace=False)
    else:
        spacing = math.floor(n_basis / n_shapes)
        plugins = [int(k * spacing) for k in range(n_shapes)]
    seen_shapes = {"basis": [0, n_basis]}

    for shape_id, shape in enumerate(list_shapes):
        shape_type = shape[0]
        args = [start]
        args += [get_color_concept(colour)]
        if len(shape) > 1:
            args += shape[1:]
        args += [0]

        graph_s, roles_graph_s, concepts_s = eval(shape_type)(*args)
        n_s = nx.number_of_nodes(graph_s)
        if shape_type == 'house':
            col_start = 1
        if shape_type =='circle':
            col_start = 4

        print(f"Col start for {shape} is {col_start}")

        basis.add_nodes_from(graph_s.nodes())
        basis.add_edges_from(graph_s.edges())
        basis.add_edges_from([(start, plugins[shape_id])])

        if shape_type == "circle":
            if np.random.random() > 0.5:
                a = np.random.randint(1, 4)
                b = np.random.randint(1, 4)
                basis.add_edges_from([(a + start, b + plugins[shape_id])])

        temp_labels = [r + col_start for r in roles_graph_s]
        role_id += temp_labels
        start += n_s

        # colour_concept = 5 if colour == 'red' else 6
        #
        # for t in temp_labels:
        #     new_c = np.array([[colour_concept, t]])
        #     concepts = np.concatenate((concepts, new_c))

        concepts = np.concatenate((concepts, concepts_s))

    if add_random_edges > 0:
        # add random edges between nodes:
        for p in range(add_random_edges):
            src, dest = np.random.choice(nx.number_of_nodes(basis), 2, replace=False)
            # print(src, dest)
            basis.add_edges_from([(src, dest)])

    return basis, role_id, concepts, plugins



def perturb(graph_list, p):
    perturbed_graph_list = []
    for G_original in graph_list:
        G = G_original.copy()
        edge_count = int(G.number_of_edges() * p)
        # randomly add the edges between a pair of nodes without an edge.
        for _ in range(edge_count):
            while True:
                u = np.random.randint(0, G.number_of_nodes())
                v = np.random.randint(0, G.number_of_nodes())
                if (not G.has_edge(u, v)) and (u != v):
                    break
            G.add_edge(u, v)
        perturbed_graph_list.append(G)
    return perturbed_graph_list


def generate_ba_shapes_graph_class():
    num_graphs_per_class = 2
    basis_type = "ba"
    width_basis = 20
    nb_shapes = 3

    list_colours = ['red', 'blue']
    list_shapes = ['circle', 'house']

    for (color_str, shape_str) in list(itertools.product(list_colours, list_shapes)):
        for i in range(num_graphs_per_class):
            list_shapes = [[shape_str]] * nb_shapes

            G, role_id, concepts, _ = build_graph(width_basis, basis_type, list_shapes, color_str, start=0, m=5)
            G = perturb([G], 0.01)[0]

            name = basis_type + "_" + str(width_basis) + "_" + str(nb_shapes)

            nx.readwrite.write_gpickle(G, f"{i}_graph_{name}.gpickel")
            np.save(f"{i}_role_ids_{name}.npy", np.array(role_id))
            np.save(f"{i}_color_concepts_{name}.npy", np.array(concepts))


            print(role_id)
            print(concepts)


def main():
    generate_ba_shapes_graph_class()



if __name__ == '__main__':
    main()
