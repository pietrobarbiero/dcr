# -*- coding: utf-8 -*-
"""Graph Class Copy of BA_Shapes.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-G-54HRD0US3vXbV0qgutiucTH170R32
"""

import os
from matplotlib import pyplot as plt
from matplotlib.backends.backend_agg import FigureCanvasAgg as FigureCanvas
from matplotlib.figure import Figure
import matplotlib.colors as colors
import networkx as nx
import numpy as np
from torch.utils.tensorboard import SummaryWriter
import math
import abc
import itertools

def get_color_concept(color_str):
    if color_str == 'green':
        return 1
    elif color_str == 'red':
        return 80
    elif color_str == 'blue':
        return 15
    # elif color_str == 'orange':
    #     return 24
    # elif color_str == 'cobalt':
    #     return 80

class FeatureGen(metaclass=abc.ABCMeta):
    """Feature Generator base class."""
    @abc.abstractmethod
    def gen_node_features(self, G):
        pass

class ConstFeatureGen(FeatureGen):
    """Constant Feature class."""
    def __init__(self, val):
        self.val = val

    def gen_node_features(self, G):
        feat_dict = {i:{'feat': np.array(self.val, dtype=np.float32)} for i in G.nodes()}
        nx.set_node_attributes(G, feat_dict)

class ColorFeatureGen(FeatureGen):
    """Color feature gen class"""
    def __init__(self, vals):
        self.vals = vals

    def gen_node_features(self, G):
        # feat_dict = {i: {'feat': (((int(self.vals[i]) & (1 << np.arange(8)))) > 0).astype(int).astype(np.float32)} for i in G.nodes()}
        feat_dict = {i:{'feat': np.array(self.vals[i], dtype=np.float32)} for i in G.nodes()}
        print(feat_dict)
        nx.set_node_attributes(G, feat_dict)

# BA Shapes Code is from GNNExplainer repo: https://github.com/RexYing/gnn-model-explainer/tree/bc984829f4f4829e93c760e9bbdc8e73f96e2cc1
def house(start, color=None, role_start=0):
    graph = nx.Graph()
    graph.add_nodes_from(range(start, start + 4))
    graph.add_edges_from(
        [
            (start, start + 1),
            (start + 1, start + 2),
            (start + 2, start + 3),
            (start + 3, start),
        ]
    )
    # graph.add_edges_from([(start, start + 2), (start + 1, start + 3)])
    graph.add_edges_from([(start + 4, start), (start + 4, start + 1)])
    # roles = [role_start, role_start, role_start + 1, role_start + 1, role_start + 2]
    roles = [role_start, role_start, role_start, role_start, role_start]

    if color:
        concepts = np.ones(len(roles)) * color
    else:
        concepts = np.ones(len(roles))

    print("House Concepts ", len(concepts))
    print("This ", graph.number_of_nodes())

    return graph, roles, concepts

def circle(start, color=None, role_start=0):
    len_cycle = 6
    graph = nx.Graph()
    graph.add_nodes_from(range(start, start + len_cycle))
    print("after ", graph.number_of_nodes())
    for i in range(len_cycle - 1):
        graph.add_edges_from([(start + i, start + i + 1)])
    graph.add_edges_from([(start + len_cycle - 1, start)])
    roles = [role_start] * len_cycle

    if color:
        concepts = np.ones(len(roles)) * color
    else:
        concepts = np.ones(len(roles)) * 2

    print("Circle Concepts ", len(concepts))
    print("This ", graph.number_of_nodes())

    return graph, roles, concepts

def star(start, color=None, role_start=0):
    peaks = 5
    graph = nx.Graph()
    graph.add_nodes_from(range(start, start + peaks + 1))
    for i in range(peaks - 1):
        graph.add_edges_from([(start, start + i + 1)])

    roles = [role_start] + ([role_start] * (peaks))

    if color:
        concepts = np.ones(len(roles)) * color
    else:
        concepts = np.ones(len(roles)) * 3

    print("Star Concepts ", len(concepts))
    print("This ", graph.number_of_nodes())

    return graph, roles, concepts

def grid(start, color=None, role_start=0, dim=3):
    """ Builds a 2by2 grid
    """
    grid_G = nx.grid_graph([dim, dim])
    print("This graph ", grid_G.nodes())
    grid_G = nx.convert_node_labels_to_integers(grid_G, first_label=start)
    roles = [role_start for i in range(grid_G.number_of_nodes())]

    if color:
        concepts = np.ones(len(roles)) * color
    else:
        concepts = np.ones(len(roles)) * 4

    print("Grid Concepts ", len(concepts))
    print("This ", grid_G.number_of_nodes())

    return grid_G, roles, concepts



def ba(start, width, color=None, role_start=0, m=5):
    graph = nx.barabasi_albert_graph(width, m)
    graph.add_nodes_from(range(start, start + width))
    nids = sorted(graph)
    mapping = {nid: start + i for i, nid in enumerate(nids)}
    graph = nx.relabel_nodes(graph, mapping)

    roles = [role_start for i in range(width)]

    if color:
        concepts = np.ones(len(roles)) * get_color_concept(color)
    else:
        concepts = np.zeros(len(roles))

    print("BA Concepts ", len(concepts))
    print("This ", graph.number_of_nodes())

    return graph, roles, concepts


def build_graph(width_basis, basis_type, list_shapes, color=None, start=0, rdm_basis_plugins=False, add_random_edges=0, m=5):
    if basis_type == "ba":
        basis, role_id, concepts = eval(basis_type)(start, width_basis, m=m, color=None)

    n_basis, n_shapes = nx.number_of_nodes(basis), len(list_shapes)
    start += n_basis  # indicator of the id of the next node

    # Sample (with replacement) where to attach the new motifs
    if rdm_basis_plugins is True:
        plugins = np.random.choice(n_basis, n_shapes, replace=False)
    else:
        spacing = math.floor(n_basis / n_shapes)
        plugins = [int(k * spacing) for k in range(n_shapes)]
    seen_shapes = {"basis": [0, n_basis]}

    counter = 0
    for shape_id, shape in enumerate(list_shapes):
        color=None
        # color = 'blue'
        # if counter >= 40:
        #     color = 'red'
        # elif counter >= 30:
        #     color = 'orange'

        shape_type = shape[0]
        args = [start]
        args += [color]
        if len(shape) > 1:
            args += shape[1:]
        args += [0]

        graph_s, roles_graph_s, concepts_s = eval(shape_type)(*args)
        n_s = nx.number_of_nodes(graph_s)
        if shape_type == 'house':
            col_start = 1
        if shape_type == 'circle':
            col_start = 4
        if shape_type == 'star':
            col_start = 5
        if shape_type == 'grid':
            col_start = 7

        print(f"Col start for {shape} is {col_start}")

        basis.add_nodes_from(graph_s.nodes())
        basis.add_edges_from(graph_s.edges())
        basis.add_edges_from([(start, plugins[shape_id])])

        # if shape_type == "circle":
        #     if np.random.random() > 0.5:
        #         a = np.random.randint(1, 4)
        #         b = np.random.randint(1, 4)
        #         basis.add_edges_from([(a + start, b + plugins[shape_id])])

        temp_labels = [r + col_start for r in roles_graph_s]
        role_id += temp_labels
        start += n_s

        # colour_concept = 5 if colour == 'red' else 6
        #
        # for t in temp_labels:
        #     new_c = np.array([[colour_concept, t]])
        #     concepts = np.concatenate((concepts, new_c))
        print(concepts)
        concepts = np.concatenate((concepts, concepts_s))

        counter += 1

    print("All Concepts ", len(concepts))
    print("This ", basis.number_of_nodes())

    if color:
        feature_generator = ColorFeatureGen(concepts)
        feature_generator.gen_node_features(basis)
    else:
        feature_generator = ConstFeatureGen(1)
        feature_generator.gen_node_features(basis)

    if add_random_edges > 0:
        # add random edges between nodes:
        for p in range(add_random_edges):
            src, dest = np.random.choice(nx.number_of_nodes(basis), 2, replace=False)
            # print(src, dest)
            basis.add_edges_from([(src, dest)])


    return basis, role_id, concepts, plugins



def perturb(graph_list, p):
    perturbed_graph_list = []
    for G_original in graph_list:
        G = G_original.copy()
        edge_count = int(G.number_of_edges() * p)
        # randomly add the edges between a pair of nodes without an edge.
        for _ in range(edge_count):
            while True:
                u = np.random.randint(0, G.number_of_nodes())
                v = np.random.randint(0, G.number_of_nodes())
                if (not G.has_edge(u, v)) and (u != v):
                    break
            G.add_edge(u, v)
        perturbed_graph_list.append(G)
    return perturbed_graph_list


def generate_ba_shapes_graph_class():
    num_graphs_per_class = 250
    basis_type = "ba"
    width_basis = 20
    nb_shapes = 3

    list_colours = ['red', 'blue']
    list_shapes = ['circle', 'house']

    counter = 0

    ys = []

    for y, (color_str, shape_str) in enumerate(list(itertools.combinations(list_colours, list_shapes))):
        for i in range(num_graphs_per_class):
            list_shapes = [[shape_str]] * nb_shapes

            G, role_id, concepts, _ = build_graph(width_basis, basis_type, list_shapes, color_str, start=0, m=5)
            G = perturb([G], 0.01)[0]

            name = basis_type + "_" + str(width_basis) + "_" + str(nb_shapes)

            nx.readwrite.write_gpickle(G, f"./data/ba_shapes/{counter}_graph_{name}.gpickel")
            np.save(f"data/ba_shapes/{counter}_role_ids_{name}.npy", np.array(role_id))
            np.save(f"data/ba_shapes/{counter}_color_concepts_{name}.npy", np.array(concepts))
            np.save(f"data/ba_shapes/{counter}_y_{name}.npy", np.array([y]))



            counter += 1

        ys.append(y)

    print(ys)


def generate_ba_shapes_graph_class_pure_sturcture():
    num_graphs_per_class = 250
    basis_type = "ba"
    width_basis = 20
    nb_shapes = 1

    list_shapes = ['circle', 'house', 'star', 'grid']
    counter = 0
    ys = []

    for y, (shape1, shape2) in enumerate(list(itertools.combinations(list_shapes, 2))):
        for i in range(num_graphs_per_class):
            list_shapes = [[shape1]] * nb_shapes + [[shape2]] * nb_shapes

            G, role_id, concepts, _ = build_graph(width_basis, basis_type, list_shapes, None, start=0, m=5)
            G = perturb([G], 0.01)[0]

            name = basis_type + "_" + str(width_basis) + "_" + str(nb_shapes)

            nx.readwrite.write_gpickle(G, f"./data/ba_shapes2/{counter}_graph_{name}.gpickel")
            np.save(f"data/ba_shapes2/{counter}_role_ids_{name}.npy", np.array(role_id))
            np.save(f"data/ba_shapes2/{counter}_color_concepts_{name}.npy", np.array(concepts))
            np.save(f"data/ba_shapes2/{counter}_y_{name}.npy", np.array([y]))

            if 5 in concepts:
                print(shape1, " ", shape2)
                assert(5 not in concepts)

            counter += 1

        ys.append(y)

    print(ys)


def generate_ba_shapes_node_class():
    nb_shapes=80
    width_basis=300
    feature_generator=None
    m=5

    basis_type = "ba"
    list_shapes = [["house"]] * nb_shapes

    plt.figure(figsize=(8, 6), dpi=300)

    G, role_id, concepts, _ = build_graph(width_basis, basis_type, list_shapes, None, start=0, m=5)
    G = perturb([G], 0.01)[0]

    name = basis_type + "_" + str(width_basis) + "_" + str(nb_shapes)

    print(role_id)
    print(concepts)

    nx.readwrite.write_gpickle(G, f"data/ba_shapes/graph_{name}.gpickel")
    np.save(f"data/ba_shapes/role_ids_{name}.npy", np.array(role_id))
    np.save(f"data/ba_shapes/concepts_{name}.npy", np.array(concepts))



def main():
    # generate_ba_shapes_graph_class()

    generate_ba_shapes_graph_class_pure_sturcture()

    # generate_ba_shapes_node_class()



if __name__ == '__main__':
    main()
